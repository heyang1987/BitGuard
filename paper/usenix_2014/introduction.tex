\vspace{-10pt}
\section{Introduction}\label{sec:introduction}
\vspace{-5pt}
%Space Exploration has benefited us in almost every aspect of our lives, from communications (e.g., cellphones, internet) to transportation (e.g., GPS) to entertainment (e.g., satellite television and audio service), etc. 
Humans have a longstanding curiosity about outer space. Since the launch of the first artificial satellite, Sputnik 1~\cite{sputnik1}, in 1957, over 6,000 satellites have been launched into space. There are more than 1,000 operating satellites in orbit around Earth~\cite{satellite:total} today, and an estimated 1,200 satellites will be launched over the next decade~\cite{satellite:next10years}. As of 2012, more than 130 manned spacecraft have been launched by the United States~\cite{space:shuttle:list}. There are currently two operational space stations, and seven more are planned over the next decade~\cite{space:station:tiangong2}\cite{space:station:almaz}\cite{space:station:opsek}\cite{space:station:tiangong3}. Given the high cost and vital importance of spacecraft rovers and satellites, as well as their increasing functionality and complexity, the hardware and software reliability requirements are stringent.

One of the most important factors that affect the reliability of spacecraft (and other equipment) is the quality of the constituent embedded components which control telemetry systems, command systems, attitude control systems, and more~\cite{fundamentals:space}. For example, the MSX (Midcourse Space Experiment) spacecraft, launched in the mid-1980s, was equipped with 54 embedded processors, running more than 275,000 lines of code, managing 19 subsystems~\cite{fundamentals:space}. Embedded software failures can cause serious consequences in this context. In 1996, the Ariane 5 spacecraft, which took 10 years and 7 billion (US) dollars to build, crashed due to the failure of the Flight Control Subsystem~\cite{ariane5}.

The environment outside the Earth's atmosphere is highly radioactive. The radiation is generated mainly by the sun and other stars and can cause damage to semiconductor devices~\cite{fundamentals:space}. One of the most common types of damage caused by radiation is the \textit{single event upset} (SEU). Extremely small electronic components (i.e., tens of nanometers~\cite{intel:chip:size}) are used in modern integrated circuitry; the components cannot carry much charge. As a result, one high-energy ionizing particle passing through an integrated circuit can release enough charge to change the state of a binary digit, causing a stored bit to change to its opposite value (i.e., a 0-bit can become a 1-bit, and vice-versa~\cite{fundamentals:space}). The damage caused by an SEU can range from system malfunction to system crash.
% This phenomenon is known as a \textit{Single Bit Upset}. It has also been observed that two or more stored bits can be changed by one high-energy particle striking at certain angles of incidence, known as a \textit{Multiple Bit Upset} (MBU). The damage caused by an SEU (or MBU) can range from system dysfunction to system crash, both of which are intolerable for spacecraft embedded systems. %Modern approaches used to prevent and correct SEU errors often introduce additional hardware and software to the target system. Systems designed to be used in space often contain processors fabricated using Silicon On Insulator technology, which effectively reduces the size of the processor, and therefore reduces the vulnerable area that a highly-charged particle could strike.Triple modular redundancy (TMR)~\cite[p.645]{fundamentals:space} uses three identical systems (either physically or temporally duplicated) to simultaneously perform identical tasks, where the correct result is then decided by a majority vote. Due to the inherent randomness of Single Event Upsets, the chance that two charged particles would strike parallel locations in two different systems at the same time is incredibly low, making TMR a very popular practice in spite of the memory expense. Another popular SEU correction method is the use of codes such as the Hamming Code to correct bit errors~\cite{Shirvani2001EDAC}. However, most of these processes are supplemented by periodic memory scrubbing and hardware watchdog timers used to check execution flow and abnormal program executions caused by SEUs~\cite[p.648]{fundamentals:space}. 

Modern approaches used to prevent and correct SEU errors often introduce additional hardware to the target system. In this paper, we present a {\em software-only} approach that detects and corrects SEUs in RAM. The paper focuses on the system stack, which is the most important and dynamic region in memory. The system stack is protected by injecting customized code into the target assembly generated by AVR-GCC. After injection, each callee computes and saves the checksum of its caller's current stack frame and duplicates the caller's stack frame when the callee enters its function body. Before the callee returns, it verifies the stack frame of the caller using the saved checksum and overwrites the stack frame using the duplicate, if an SEU is detected. Our approach changes the target system software and does not introduce additional hardware. Since our approach operates at the assembly level, it is language and application neutral. To demonstrate our approach, an AVR microprocessor, the ATmega644~\cite{atmel:avr}, is used in the paper. 

The main contributions of our work are as follows: (i) We present an approach that protects the system stack by injecting assembly code at the beginning and end of each application function. (ii) We present an implementation of the approach, using the popular AVR architecture as a target. (iii) We verify the protection efficacy of our approach and evaluate performance in terms of space and speed overhead using three applications with different stack usage patterns.

%(i) We summarize the key operations regarding code injection by analyzing the assembly code generated by AVR-GCC with the optimization level set to \texttt{none}. Each operation represents a phase in the execution sequence, such as initializing the function stack, function return, etc. (ii) We present an algorithm used to scan the AVR assembly code, and categorize operations performed by each line of the assembly code based on the assembly metadata we designed. Based on scan results, customized assembly code is injected into the target assembly code, handling register saving and restoring, checksum computation, memory duplication, etc. (iii) Finally, three (?) real-world applications are considered to verify our approach, and evaluate its performance using an AVR simulator.

{\bf Paper Organization.} Section \ref{sec:related_work} summarizes key elements of related work. Section \ref{sec:background} provides background related to our approach, including the microprocessor architecture, AVR function call process, and AVR toolchain. Section \ref{sec:design} presents the design and implementation of our approach. Section \ref{sec:evaluation} presents an evaluation of the approach, with an emphasis on ROM size and execution speed overhead. Finally, Section \ref{sec:conclusion} concludes with a summary of contributions and pointers to future work.