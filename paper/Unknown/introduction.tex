\section{Introduction}\label{sec:introduction}

%Space Exploration has benefited us in almost every aspect of our lives, from communications (e.g., cellphones, internet) to transportation (e.g., GPS) to entertainment (e.g., satellite television and audio service), etc. 
Humans have a longstanding curiosity about outer space. Since the launch of the first artificial satellite, Sputnik 1~\cite{sputnik1}, in 1957, over 6,000 satellites have been launched into space. There are more than 1,000 operating satellites in orbit around Earth~\cite{satellite:total} today, and an estimated 1,200 satellites will be launched over the next decade~\cite{satellite:next10years}. As of 2012, more than 130 manned spacecraft have been launched by the United States~\cite{space:shuttle:list}. There are currently two operational space stations, and seven more are planned over the next decade~\cite{space:station:tiangong2}\cite{space:station:almaz}\cite{space:station:opsek}\cite{space:station:tiangong3}. A total of 355 astronauts from 16 different countries have flown into space, among which 14 were killed during accidents~\cite{space:shuttle:numbers}. Because of the high cost and vital importance of spacecraft rovers and satellites, as well as their increasing functionality and complexity, the hardware and software reliability requirements are extremely high.

One of the most important factors that affect the reliability of spacecraft (and other space equipment) is the quality of constituent embedded systems which control telemetry systems, command systems, attitude control systems, and more~\cite[p.654]{fundamentals:space}. For example, the MSX (Midcourse Space Experiment) spacecraft, launched in the mid-1980s, was equipped with 54 embedded processors, running more than 275,000 lines of code, managing 19 subsystems~\cite[p.655]{fundamentals:space}. Embedded software failures could cause serious consequences in this context. In 1996, the Ariane 5 spacecraft, which took 10 years and 7 billion dollars to build, crashed due to the failure of the Flight Control Subsystem when it performed a conversion from a 64-bit floating point value to a 16-bit signed integer value~\cite{ariane5}.

The environment outside the Earth's atmosphere is highly radioactive. The radiation is mostly generated by the sun and space itself, and can cause damage to semiconductor devices~\cite[p.636]{fundamentals:space}. One of the most common types of damage caused by radiation is the \textit{Single Event Upset} (SEU). Extremely small electronic components (i.e., tens of nanometers~\cite{intel:chip:size}) are used in modern integrated circuitry; the components cannot carry much charge. As a result, one high-energy ionizing particle passing through an integrated circuit could release enough charge to change the state of a binary digit, causing a stored bit to change to its opposite value (i.e., a 0-bit can become a 1-bit, and vice-versa~\cite[p.637]{fundamentals:space}), known as the \textit{Single Bit Upset}. It also has been observed that two or more stored bits can be changed by one high-energy particle, known as the \textit{Multiple Bit Upset}. The damage caused by an SEU can range from system dysfunction to system crash, both of which are intolerable for spacecraft embedded systems.

Modern approaches used to prevent and correct SEU errors introduce additional hardware to the target system. Triple modular redundancy (TMR)~\cite[p.645]{fundamentals:space} uses three identical systems to simultaneously perform identical tasks, and the correct result is decided by a majority vote. N-version programming involves two or more teams developing software for identical requirements. When applied in a TMR context, the intuition is that independent teams are not likely to introduce identical bugs~\cite[p.646]{fundamentals:space}. A hardware watchdog timer can be used to check execution flow to detect abnormal program executions caused by SEUs~\cite[p.648]{fundamentals:space}. (More will be added after related work is done.)

In this paper, we present an approach that detects and corrects SEUs in RAM. Our approach focuses on the Single Bit Upset, which constitute about 97\% of the memory errors caused by the SEUs. The paper focuses on the system stack, which is the most important and dynamic region in memory. Each callee computes and saves the checksum of its caller's current stack frame, and duplicate the caller's stack frame when the callee enters its function body. Before the callee returns, it verifies the stack frame of the caller using the saved checksum, and overwrites the stack frame using the duplicate if an SEU is detected. Our approach changes the target system software and does not introduce additional hardware. Since our approach operates at the assembly level, it is conceptually language and application neutral. To demonstrate our approach, an AVR microprocessor, ATmega644~\cite{atmel:avr}, is used in the paper. 

The main contributions of our work are as follows: (i) We summarize the key operations performed by the assembly code by analyzing the assembly code generated by AVR-GCC with the optimization level set to \texttt{none}. Each operation represents a phase in the execution sequence, such as initializing the function stack, function return, etc. (ii) We present an algorithm used to scan the AVR assembly code, and categorize operations performed by each line of the assembly code based on the assembly metadata we designed. Based on scan results, customized assembly code is injected into the target assembly code, handling register saving and restoring, checksum computation, memory duplication, etc. (iii) Finally, three (?) real-world applications are considered to verify our approach, and evaluate its performance using an AVR simulator.

{\bf Paper Organization.} Section \ref{sec:related_work} summarizes key elements of related work. Section \ref{sec:background} discuss the background knowledge related to our approach, including the microprocessor architecture, AVR-GCC, etc. Section \ref{sec:design} presents the design and implementation of our approach. Section \ref{sec:evaluation} presents an evaluation of the approach using three applications. Finally, Section \ref{sec:conclusion} concludes with a summary of contributions and pointers to the future work.