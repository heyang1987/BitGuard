\section{Conclusion}\label{sec:conclusion}

The single event upset is among the most common types of system faults introduced by radiation, posing significant risk to spacecraft embedded systems. Modern approaches to guarding against such faults often introduce additional hardware to detect and correct SEU errors in target systems. In this paper, we present a software-only approach to protecting embedded system memory from SEUs. 

Our approach focuses on the system stack, which is the most important and dynamic region in memory. The stack is protected by injecting auxiliary assembly code within the target program. The prototype implementation is based on the AVR architecture, but is easily adapted to other architectures. Analytical and experimental results show that our approach detects and corrects SEU errors as expected. 

A study on protection efficacy has been provided, analyzing the probability of successful SEU protection as SEU frequency is increased. Experimental results for both ROM and execution (speed) overhead have been provided, using three applications with different degrees of stack dynamism. Since the size of the injected code is fixed, space overhead depends only on the number of functions in the target program and the size of each function. Speed overhead depends largely on function frame size and stack dynamism, as well as the occurrence rate of SEUs. Results show that for typical programs, our approach achieves a stack protection success rate of over 99\%.

{\bf Future Work}. Our future work follows four tracks. The first is focused on protecting global portions of RAM. In our current design, we ignore the .data and .bss sections used to store global and static variables. Since global and static variables are commonly used in embedded applications, introducing protection to these sections will improve the utility of our approach. The second involves introducing compression to the stack frame copy process. In our current design, stack frames are directly copied. Although compression will increase ROM and execution (speed) overhead, RAM usage and the probability that the stack frame copies are affected by SEUs can be reduced. Third, we plan to extend our approach to other GCC optimization levels. In the current design, optimization level option -O0 is used. However, other options, such as -O2 or -Os, are frequently used by developers. Applying our design to other levels involves studies on assembly code generated with other optimization levels and will further improve the utility of our approach. Finally, we plan to add support for external RAM. Internal RAM is a valuable resource in embedded systems. Our approach uses the internal RAM to store the stack frame copies, reducing the RAM space available for the target program. Adding external RAM can provide more space to store stack frame copies and offers more flexibility in future designs.

%Third, we plan to study scenarios where SEU occurrence is not uniformly distributed. In this paper, a uniform distribution is assumed. However, in real systems, the distribution depends on the altitude and angle of the device towards the sun.